system {
  zone_id = "zone_1"
  environment = "test"
}

network {
  udp_host  = "0.0.0.0"
  udp_port  = 100
  http_host = "0.0.0.0"
  http_port = 51200

  # cél eszköz, ahová a kiszámolt pozíció megy (UDP)
  sink_host = "127.0.0.1"
  sink_port = 6000
}

crypto {
  aes_key_hex = "00112233445566778899AABBCCDDEEFF"
  enable_gcm_first_nonce = true
  enable_gcm_zero_nonce  = true
  enable_ctr_first_iv    = true
}

tdoa {
  zone_name = "Example Zone"

  # Fizikai anchorok listája.
  # - A lista tetszőleges hosszú lehet (0..N).
  # - Új anchor itt vagy a webes /config felületen vehető fel.
  # - Minden elemhez tartozik id, pozíció, opcionális addr (IP:port).
  anchors = [
    {
      id       = "A1"
      name     = "Anchor 1"
      position = { x = 0.0, y = 0.0, z = 0.0 }
      enabled  = true
      # opcionális: IP:port mapping a bejövő UDP forráshoz
      # addr     = "192.168.1.10:100"
    }
    # ide jöhetnek további anchorok:
    # {
    #   id       = "A2"
    #   name     = "Anchor 2"
    #   position = { x = 10.0, y = 0.0, z = 0.0 }
    #   enabled  = true
    #   addr     = "192.168.1.11:100"
    # }
  ]

  # Opcionális: ismert / elnevezett TAG-ek a UI-hoz.
  # A valós TAG ID-k futás közben derülnek ki, és RAM-ban kezeljük őket.
  tags = [
    {
      id   = "TAG001"
      name = "Worker 1"
    }
  ]

  map {
    # Háttérkép a térképes UI-hoz (nem kötelező négyszög alakú helyiség)
    image_path = "/static/img/map_placeholder.png"

    # Alap bounding box a koordináta-rendszerhez (méterben).
    # Ezt használhatja a rajzoló skálázáshoz, akkor is, ha a zóna alakja L-alakú.
    width_m    = 20.0
    height_m   = 10.0
    origin     = { x = 0.0, y = 0.0 }

    # Általános zóna-alak leírása (tetszőleges sokszög).
    # Példa: L-alakú zóna, 1 m felbontású alaprajz koordinátákban.
    shape {
      type = "polygon"

      # A polygon csúcsai (x,y), a zóna külső határvonalát adják meg.
      # (0,0) → (10,0) → (10,5) → (5,5) → (5,10) → (0,10) → vissza (0,0)
      vertices = [
        { x = 0.0, y = 0.0 }
        { x = 10.0, y = 0.0 }
        { x = 10.0, y = 5.0 }
        { x = 5.0, y = 5.0 }
        { x = 5.0, y = 10.0 }
        { x = 0.0, y = 10.0 }
      ]
    }
  }

  # FUTÁS KÖZBEN ÁLLÍTHATÓ SZÁMÍTÁSI PARAMÉTEREK (azonnal érvényesek)
  runtime {
    # csak ezt a zónát dolgozza fel (egyezzen az UWB csomag zone_id=0x.... mezőjével!)
    expected_zone_id_hex = "0x5B31"

    # Anchore-onként tárolt nyers mérések bufferelése
    buffer {
      # hány utolsó mérés maradjon meg anchore-onként RAM-ban
      per_anchor_size     = 50
      # ennyi másodpercnél régebbi mérést a solver már figyelmen kívül hagyhat
      max_age_sec         = 2.0
      # mennyi snapshotot használunk egy anchorból egy solve-hoz
      snapshots_per_anchor = 5
    }

    # TDoA / pozíció-számítás paraméterei
    solver {
      # fénysebesség (m/s) – TDoA számításhoz
      c_m_per_s      = 299792458.0
      # timestamp egység skálázás (ha a firmware nem másodpercet küld)
      # pl. ha 1 tick = 1e-12 s, akkor ts_unit_scale = 1e-12
      ts_unit_scale  = 1.0

      # minimum anchor szám, ami alatt nem próbálunk pozíciót számolni
      min_anchor_count = 3          # 2D-hez tipikusan 3
      min_good_anchors = 3          # outlier-szűrés után is kell ennyi

      # iterációs korlát nemlineáris solverhez
      max_iterations = 20
      # ha az iterációk közötti változás ennél kisebb, megállunk
      stop_threshold = 1e-4

      # outlier threshold a megoldott pozíció maradékaira (méterben)
      max_residual_m = 2.0
      # outlier eldobás percentil alapján (0.0–1.0)
      anchor_outlier_reject_pct = 0.2

      # referencia anchor választási stratégia TDoA-hoz
      # possible: "closest", "lowest_id", "fixed"
      reference_anchor = "closest"

      # Levenberg–Marquardt vagy sima Gauss–Newton
      use_lm_solver = true

      # geometriakontroll: ha a geometriája a hármas anchor-kombónak túl degenerált, reject
      enable_geometry_checks = true

      # kezdő becslés a solvernek (méterben)
      initial_guess = { x = 0.0, y = 0.0, z = 0.0 }

      # debug / forward működés
      debug_output = false
      # raw | filtered | both – hogyan küldjük a pozíciót a sink felé
      forward_mode = "filtered"
    }

    # Szűrési / smoothing paraméterek (pl. Kalman-szűrőhöz)
    filter {
      # mérési szórás (pozícióra) [m]
      pos_sigma_m     = 0.5
      # folyamat zaj intenzitás (Q) – mozgásmodell
      process_noise   = 0.1
      # ha egy TAG ennyi ideig nem frissül, UI-ban „stale”-nek tekinthető
      tag_max_age_sec = 2.0
      # max. ugrás, amit még elfogadunk két solve között (m)
      max_jump_m      = 5.0
      # sebesség csillapítás (0–1), ha a filterben van velocity state
      velocity_damping = 0.8
    }
  }
}

web {
  session_timeout_sec = 1800
}

users = [
  {
    username      = "diag"
    password_hash = "scrypt:32768:8:1$I43nkuNnsea6bGoB$fd9fca93a169e7fac11cdc0c8009af23a299461de6f04113c9122cbe2c6099b41916578db76b68478a49d4d0cd584785efa43d109f24a3545a921d2722b49e83"
    role          = "diag"
  },
  {
    username      = "admin"
    password_hash = "scrypt:32768:8:1$KIyyVG0g2mcvA4yA$3f877837c4ed8dd7dc422187a6fa9e246af0e13e98a474c47860c63e4436fdbf45411c252761ebc0c4ae0924a233a15d79b641532a5dc18633a6704b5bc0b3c6"
    role          = "admin"
  },
  {
    username      = "root"
    password_hash = "scrypt:32768:8:1$7frmE5mcAjAQFVlf$0ad475cfe724590885ca40fe0fd378f53ff942124fa344a250709a029a11c3ebccc314e39c38fddef46af578c9064b35e969a4dcc71ba8675895410ad5d938f0"
    role          = "root"
  }
]

permissions {
  admin_editable = [
    "network.*",  # port / host módosítható, de csak restart után lép életbe
    "tdoa.*",     # számítási paraméterek, anchor metaadat, map, shape, stb.
    "system.*"
  ]

  root_only = [
    "crypto.*",
    "users.*"
  ]
}
